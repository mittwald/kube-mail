import * as tsj from "ts-json-schema-generator";
import { Config, Schema } from "ts-json-schema-generator";
import * as path from "path";
import * as fs from "fs";
import * as jsonref from "json-refs";
import { CustomResourceDefinition } from "@mittwald/kubernetes/types/apiextensions/v1beta1";
import { APIObject } from "@mittwald/kubernetes/types/meta";
import * as yaml from "js-yaml";
import {apiGroup, apiVersion} from "../src/k8s/api";
import {CustomResourceColumnDefinition} from "@mittwald/kubernetes/types/apiextensions/v1beta1/customresourcedefinition";

function purgeSchemaForKubernetes(s: Schema) {
    if (s.additionalProperties === false) {
        delete s.additionalProperties;
    }

    if (s.properties) {
        for (const propName of Object.keys(s.properties)) {
            if (typeof s.properties[propName] === "object") {
                purgeSchemaForKubernetes(s.properties[propName] as Schema);
            }
        }
    }

    if (s.anyOf) {
        for (const anyOf of s.anyOf) {
            purgeSchemaForKubernetes(anyOf as Schema);
        }
    }

    if (s.items) {
        if (Array.isArray(s.items)) {
            for (const item of s.items) {
                purgeSchemaForKubernetes(item as Schema);
            }
        } else {
            purgeSchemaForKubernetes(s.items as Schema);
        }
    }

    if (s.additionalProperties) {
        purgeSchemaForKubernetes(s.additionalProperties as Schema);
    }

    return;
}

const fileContents: Record<string, string> = {};
const crdPath = path.join(__dirname, "..", "chart", "crds");

const generateFromSourceFile = async (sourceFile: string, kind: string, plural: string, columns: CustomResourceColumnDefinition[]) => {
    const targetFile = path.join(crdPath, `${kind.toLowerCase()}_crd.yaml`);
    const generatorConfig: Config = {
        path: sourceFile,
        tsconfig: path.join(__dirname, "..", "tsconfig.json"),
        type: kind,
        expose: "none",
        jsDoc: "extended",
        topRef: false,
    };

    const generator = tsj.createGenerator(generatorConfig);
    const schema = generator.createSchema(generatorConfig.type);

    // Set resolveCirculars to "true" -- if set to `false`, the generated schema
    // will map circular references to JSON references (with `$ref`), which are
    // not supported by Kubernetes.
    //
    // So, what we actually WANT to do here is to resolve circular references at
    // first so that they are resolved into ACTUAL circular JavaScript
    // references (in which case, the subsequent JSON.stringify will fail --
    // which is exactly the desired behaviour).
    const { resolved } = await jsonref.resolveRefs(schema, { resolveCirculars: true });

    // This will fail if there are circular references somewhere in the schema.
    try {
        JSON.stringify(resolved);
    } catch (err) {
        console.error(err);
        console.error(JSON.stringify(schema, undefined, 4));
        process.exit(1);
    }

    delete (resolved as any)["definitions"];
    delete (resolved as any)["properties"]["metadata"];
    (resolved as any).required = (resolved as any).required.filter((f: string) => f !== "metadata");

    purgeSchemaForKubernetes(resolved);

    const crd: APIObject<"CustomResourceDefinition", "apiextensions.k8s.io/v1beta1"> & CustomResourceDefinition = {
        apiVersion: "apiextensions.k8s.io/v1beta1",
        kind: "CustomResourceDefinition",
        metadata: {
            name: `${plural}.${apiGroup}`,
        },
        spec: {
            group: apiGroup,
            scope: "Namespaced",
            names: {
                kind,
                plural,
            },
            versions: [
                {
                    name: apiVersion,
                    served: true,
                    storage: true,
                },
            ],
            additionalPrinterColumns: [
                ...columns,
                { name: "Age", type: "date", JSONPath: ".metadata.creationTimestamp" },
            ],
            validation: {
                openAPIV3Schema: resolved,
            },
        },
    };

    fileContents[targetFile] = "# generated by scripts/grn-crd.ts. DO NOT EDIT!\n" + yaml.dump(crd, { indent: 2, flowLevel: 130 });
};

(async() => {
    await generateFromSourceFile(path.join(__dirname, "..", "k8s", "types", "v1alpha1", "emailpolicy.ts"), "EmailPolicy", "emailpolicies", [
        {JSONPath: ".spec.default", name: "default", type: "boolean", description: "describes if this is the default policy"},
        {JSONPath: ".spec.sink.smtp.server", name: "SMTP server", type: "string", description: "which SMTP server mails are forwarded to"},
    ]);
    await generateFromSourceFile(path.join(__dirname, "..", "k8s", "types", "v1alpha1", "smtpserver.ts"), "SMTPServer", "smtpservers", [
        {JSONPath: ".spec.server", name: "SMTP server", type: "string", description: "SMTP server hostname"},
    ]);

    for (const file of Object.keys(fileContents)) {
        fs.writeFileSync(file, fileContents[file], {encoding: "utf-8"});
    }
})().catch(err => {
    console.error(err);
    process.exit(1);
});
